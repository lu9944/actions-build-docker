name: Extract APT Packages and Upload to FTP

on:
  workflow_dispatch:
    inputs:
      base_image:
        description: 'Base Docker image (must match target system architecture)'
        required: false
        default: 'pytorch/pytorch:2.9.0-cuda12.6-cudnn9-devel'

      dockerfile_path:
        description: 'Path to Dockerfile to auto-extract APT packages from (optional, overrides apt_packages if set)'
        required: false
        default: ''

      apt_packages:
        description: 'APT packages to extract (space-separated, will include all dependencies). Ignored if dockerfile_path is set.'
        required: false
        default: 'build-essential iputils-ping net-tools iproute2 curl dnsutils tcpdump netcat-openbsd vim sudo unzip zip screen libgl1-mesa-glx htop git openssh-server libsm6 libxext6 ninja-build libglib2.0-0 libxrender-dev gcc g++ make cmake file wget'

      pip_packages:
        description: 'pip packages to extract (space-separated, will include all dependencies)'
        required: false
        default: 'jupyter jupyterlab'

      include_recommends:
        description: 'Include recommended packages'
        required: false
        type: boolean
        default: true

      ftp_port:
        description: 'FTP server port'
        required: false
        default: '21'

      ftp_remote_path:
        description: 'Remote path on FTP server (will be created if not exists)'
        required: false
        default: '/apt-packages'

      ftp_create_subdir:
        description: 'Create timestamped subdirectory on FTP'
        required: false
        type: boolean
        default: false

      install_script_path:
        description: 'Installation script path on server (empty to skip)'
        required: false
        default: 'install_packages.sh'

      max_retries:
        description: 'FTP upload max retries'
        required: false
        type: choice
        options:
          - '1'
          - '3'
          - '5'
        default: '3'

jobs:
  extract-and-upload:
    runs-on: ubuntu-latest

    steps:
      - name: Set output variables
        run: |
          echo "TIMESTAMP=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
          echo "PACKAGE_FILE=apt-packages-$(date +%Y%m%d-%H%M%S).tar.gz" >> $GITHUB_ENV
          echo "SCRIPT_FILE=install_packages_$(date +%Y%m%d-%H%M%S).sh" >> $GITHUB_ENV
          echo "MANIFEST_FILE=package_manifest_$(date +%Y%m%d-%H%M%S).txt" >> $GITHUB_ENV

      - name: Parse packages from Dockerfile
        if: inputs.dockerfile_path != ''
        run: |
          echo "=== Parsing APT packages from Dockerfile ==="
          echo "Dockerfile path: ${{ inputs.dockerfile_path }}"

          if [ ! -f "${{ inputs.dockerfile_path }}" ]; then
              echo "Error: Dockerfile not found at ${{ inputs.dockerfile_path }}"
              exit 1
          fi

          # Extract APT packages from apt install / apt-get install commands
          # Handles multi-line commands with backslashes
          PARSED_PACKAGES=$(
              cat "${{ inputs.dockerfile_path }}" | \
              # Convert backslash continuations to single lines
              sed ':a; /\\$/N; s/\\\n//; ta' | \
              # Find apt install/apt-get install lines and extract package list
              grep -iE '^\s*(RUN|CMD)\s+(apt|apt-get)\s+install' | \
              # Remove the RUN/CMD and install keywords
              sed -E 's/^\s*(RUN|CMD)\s+(apt|apt-get)\s+install\s+(--yes|--assume-yes|-y)\s*//i' | \
              sed -E 's/\s+(--yes|--assume-yes|-y)\s*/ /g' | \
              # Remove common apt options
              sed -E 's/--[a-z-]+\s*=?\s*[^\s]*//g' | \
              # Remove pip and other non-apt commands that might be on same line
              sed -E 's/&&.*//g' | \
              sed -E 's/\|.*//g' | \
              # Clean up whitespace and special characters
              tr -s '[:space:]' ' ' | \
              sed -E 's/^\s+//; s/\s+$//' | \
              # Remove -y flags that might remain
              sed -E 's/\s+-y\s*/ /g' | \
              tr ' ' '\n' | \
              # Filter out empty lines and options
              grep -vE '^(--?|-$|&&|pip|pip3|npm|\.|/)' | \
              sort -u | \
              tr '\n' ' '
          )

          echo ""
          echo "=== Extracted APT Packages ==="
          if [ -n "$PARSED_PACKAGES" ]; then
              echo "$PARSED_PACKAGES" | tr ' ' '\n' | nl
              echo "Total: $(echo $PARSED_PACKAGES | wc -w) packages"
              echo "EXTRACTED_PACKAGES=$PARSED_PACKAGES" >> $GITHUB_ENV
              echo "PACKAGE_COUNT=$(echo $PARSED_PACKAGES | wc -w)" >> $GITHUB_ENV
          else
              echo "No APT packages found"
              echo "EXTRACTED_PACKAGES=" >> $GITHUB_ENV
              echo "PACKAGE_COUNT=0" >> $GITHUB_ENV
          fi
          echo "============================="

      - name: Create working directories
        run: |
          mkdir -p apt-packages
          mkdir -p scripts

      - name: Display configuration
        run: |
          echo "=== Package Extraction Configuration ==="
          echo "Base Image: ${{ inputs.base_image }}"
          if [ -n "${{ inputs.dockerfile_path }}" ]; then
              echo "Dockerfile: ${{ inputs.dockerfile_path }}"
              echo ""
              echo "APT Packages (from Dockerfile): ${{ env.EXTRACTED_PACKAGES }}"
              echo "APT Package Count: ${{ env.PACKAGE_COUNT }}"
          else
              echo ""
              echo "APT Packages (manual): ${{ inputs.apt_packages }}"
          fi
          echo ""
          echo "pip Packages: ${{ inputs.pip_packages }}"
          echo ""
          echo "Include Recommends: ${{ inputs.include_recommends }}"
          echo "FTP Server: ${{ secrets.FTP_SERVER }}:${{ inputs.ftp_port }}"
          echo "FTP Username: ${{ secrets.FTP_USERNAME }}"
          echo "FTP Remote Path: ${{ inputs.ftp_remote_path }}"
          echo "Create Subdir: ${{ inputs.ftp_create_subdir }}"

      - name: Create Dockerfile for package extraction
        run: |
          cat > Dockerfile.extract << 'EOF'
          ARG BASE_IMAGE=ubuntu:22.04
          FROM ${BASE_IMAGE}

          ENV DEBIAN_FRONTEND=noninteractive
          ENV TZ=UTC

          # Install tools and set up Ubuntu repositories
          RUN . /etc/os-release && \
              echo "=== System Info ===" && \
              echo "OS: $ID $VERSION_ID $VERSION_CODENAME" && \
              echo "===================" && \
              apt-get update && \
              apt-get install -y --no-install-recommends \
                  apt-rdepends \
                  dpkg-dev \
                  apt-utils \
                  curl \
                  python3 \
                  python3-pip && \
              rm -rf /var/lib/apt/lists/* && \
              # Add Ubuntu repositories (PyTorch images only have CUDA repos)
              echo "deb http://archive.ubuntu.com/ubuntu/ $VERSION_CODENAME main restricted universe multiverse" > /etc/apt/sources.list.d/ubuntu.list && \
              echo "deb http://archive.ubuntu.com/ubuntu/ $VERSION_CODENAME-updates main restricted universe multiverse" >> /etc/apt/sources.list.d/ubuntu.list && \
              echo "deb http://security.ubuntu.com/ubuntu/ $VERSION_CODENAME-security main restricted universe multiverse" >> /etc/apt/sources.list.d/ubuntu.list && \
              echo "=== Added Ubuntu repositories for $VERSION_CODENAME ===" && \
              cat /etc/apt/sources.list.d/ubuntu.list && \
              apt-get update && \
              # Verify we can find packages
              echo "=== Verifying package availability ===" && \
              apt-cache show build-essential > /dev/null && echo "✓ build-essential found" || echo "✗ build-essential NOT found" && \
              apt-cache show curl > /dev/null && echo "✓ curl found" || echo "✗ curl NOT found" && \
              rm -rf /var/lib/apt/lists/*

          RUN mkdir -p /packages && \
              mkdir -p /pip-packages && \
              mkdir -p /scripts

          COPY download_packages.sh /tmp/download_packages.sh
          RUN chmod +x /tmp/download_packages.sh

          ARG INCLUDE_RECOMMENDS=true
          ENV INCLUDE_RECOMMENDS=${INCLUDE_RECOMMENDS}

          ARG APT_PACKAGES=""
          ENV APT_PACKAGES="${APT_PACKAGES}"

          ARG PIP_PACKAGES=""
          ENV PIP_PACKAGES="${PIP_PACKAGES}"

          RUN echo "=== Starting package download ===" && \
              echo "DEBUG: APT_PACKAGES='${APT_PACKAGES}'" && \
              echo "DEBUG: PIP_PACKAGES='${PIP_PACKAGES}'" && \
              echo "DEBUG: INCLUDE_RECOMMENDS=${INCLUDE_RECOMMENDS}" && \
              /tmp/download_packages.sh && \
              echo "=== Package download completed ===" && \
              echo "=== Listing downloaded packages ===" && \
              ls -lh /packages/*.deb 2>/dev/null | head -20 && \
              DEB_COUNT=$(ls -1 /packages/*.deb 2>/dev/null | wc -l) && \
              echo "=== Total .deb files: $DEB_COUNT ===" && \
              if [ -n "$APT_PACKAGES" ] && [ "$DEB_COUNT" -eq 0 ]; then \
                  echo "ERROR: No .deb files were downloaded!"; \
                  exit 1; \
              fi && \
              echo "=== Listing downloaded pip packages ===" && \
              ls -lh /pip-packages/*.whl /pip-packages/*.tar.gz 2>/dev/null | head -20 || true && \
              PIP_COUNT=$(ls -1 /pip-packages/*.whl /pip-packages/*.tar.gz 2>/dev/null | wc -l) && \
              echo "=== Total pip files: $PIP_COUNT ===" && \
              if [ -n "$PIP_PACKAGES" ] && [ "$PIP_COUNT" -eq 0 ]; then \
                  echo "ERROR: No pip packages were downloaded!"; \
                  exit 1; \
              fi

          CMD ["/bin/bash"]
          EOF

      - name: Create package download script
        run: |
          cat > download_packages.sh << 'SCRIPT_EOF'
          #!/bin/bash

          echo "DEBUG: Script started"
          echo "DEBUG: APT_PACKAGES env var = '${APT_PACKAGES}'"

          # Use environment variable directly
          if [ -z "$APT_PACKAGES" ]; then
              echo "ERROR: No packages specified (APT_PACKAGES is empty)"
              exit 1
          fi

          echo "========================================"
          echo "APT Package Extraction Script"
          echo "========================================"
          echo "Packages to extract: $APT_PACKAGES"
          echo "Include recommends: $INCLUDE_RECOMMENDS"
          echo "========================================"
          echo

          # Update package lists
          echo "Updating package lists..."
          apt-get update

          # Build apt-get install options
          INSTALL_OPTS=""
          if [ "$INCLUDE_RECOMMENDS" != "true" ]; then
              INSTALL_OPTS="--no-install-recommends"
          fi

          echo "=== Downloading packages with dependencies ==="
          echo "Running: apt-get install --download-only $INSTALL_OPTS -y $APT_PACKAGES"
          echo ""

          # Download packages and dependencies using apt-get
          # This downloads to /var/cache/apt/archives/ by default
          apt-get install --download-only $INSTALL_OPTS -y $APT_PACKAGES 2>&1 | tee /tmp/apt-output.log
          APT_EXIT_CODE=${PIPESTATUS[0]}

          echo ""
          if [ $APT_EXIT_CODE -eq 0 ]; then
              echo "✓ Package download completed successfully"
          else
              echo "⚠ apt-get exited with code $APT_EXIT_CODE (continuing with downloaded packages)"
              echo "Checking what was downloaded..."
          fi

          # Move downloaded packages to /packages
          echo ""
          echo "Moving packages to /packages..."

          # Check what's in the cache
          echo "Contents of /var/cache/apt/archives/:"
          ls -la /var/cache/apt/archives/*.deb 2>/dev/null | wc -l
          echo "files found"

          if [ -d /var/cache/apt/archives ]; then
              # Move only .deb files, skipping partial and lock files
              mv -f /var/cache/apt/archives/*.deb /packages/ 2>/dev/null || true
          fi

          cd /packages

          DEB_COUNT=$(ls -1 *.deb 2>/dev/null | wc -l)
          echo ""
          echo "=== Download Summary ==="
          echo "Total .deb files: $DEB_COUNT"
          echo "Total size: $(du -sh . | cut -f1)"
          echo "========================="

          if [ "$DEB_COUNT" -eq 0 ]; then
              echo ""
              echo "ERROR: No .deb files were downloaded!"
              echo ""
              echo "Apt output log:"
              cat /tmp/apt-output.log
              echo ""
              echo "Checking package availability:"
              for pkg in $(echo "$APT_PACKAGES" | tr ' ' '\n' | head -5); do
                  if apt-cache show "$pkg" &>/dev/null; then
                      echo "  ✓ $pkg - AVAILABLE"
                  else
                      echo "  ✗ $pkg - NOT FOUND in repositories"
                  fi
              done
              exit 1
          fi

          # Generate package manifest with versions
          echo "Generating package manifest..."
          {
              echo "Package Manifest"
              echo "Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
              echo "Base Image: ${BASE_IMAGE:-unknown}"
              echo "Requested APT Packages: $APT_PACKAGES"
              echo "Include Recommends: $INCLUDE_RECOMMENDS"
              echo "Requested pip Packages: $PIP_PACKAGES"
              echo ""
              echo "APT Package List:"
              echo "========================================"
              for deb in *.deb; do
                  if [ -f "$deb" ]; then
                      name=$(dpkg-deb -f "$deb" Package 2>/dev/null || echo "$deb")
                      version=$(dpkg-deb -f "$deb" Version 2>/dev/null || echo "unknown")
                      size=$(du -h "$deb" | cut -f1)
                      echo "$name | $version | $size | $deb"
                  fi
              done
          } > /scripts/package_manifest.txt

          # List all downloaded packages
          echo ""
          echo "Downloaded APT packages:"
          ls -lh /packages/*.deb 2>/dev/null | head -20
          if [ $(ls -1 /packages/*.deb 2>/dev/null | wc -l) -gt 20 ]; then
              echo "... and $(($(ls -1 /packages/*.deb 2>/dev/null | wc -l) - 20)) more files"
          fi

          echo ""
          echo "=== APT package extraction completed successfully ==="

          # Handle pip packages if specified
          if [ -n "$PIP_PACKAGES" ]; then
              echo ""
              echo "========================================"
              echo "pip Package Extraction"
              echo "========================================"
              echo "Packages to extract: $PIP_PACKAGES"
              echo "========================================"
              echo ""

              cd /pip-packages

              echo "Downloading pip packages and dependencies..."
              pip3 download --dest /pip-packages $PIP_PACKAGES 2>&1 | tee /tmp/pip-output.log
              PIP_EXIT_CODE=${PIPESTATUS[0]}

              echo ""
              if [ $PIP_EXIT_CODE -eq 0 ]; then
                  echo "✓ pip package download completed successfully"
              else
                  echo "⚠ pip download exited with code $PIP_EXIT_CODE (continuing with downloaded packages)"
              fi

              PIP_COUNT=$(ls -1 *.whl *.tar.gz 2>/dev/null | wc -l)
              echo ""
              echo "=== pip Download Summary ==="
              echo "Total files: $PIP_COUNT"
              echo "Total size: $(du -sh . | cut -f1)"
              echo "============================"

              if [ "$PIP_COUNT" -eq 0 ]; then
                  echo ""
                  echo "ERROR: No pip packages were downloaded!"
                  echo ""
                  echo "pip output log:"
                  cat /tmp/pip-output.log
                  exit 1
              fi

              # Append pip packages to manifest
              echo ""
              echo "pip Package List:"
              echo "========================================" >> /scripts/package_manifest.txt
              for pkg in *.whl *.tar.gz; do
                  if [ -f "$pkg" ]; then
                      size=$(du -h "$pkg" | cut -f1)
                      echo "$pkg | $size" >> /scripts/package_manifest.txt
                  fi
              done

              echo ""
              echo "Downloaded pip packages:"
              ls -lh /pip-packages/*.whl /pip-packages/*.tar.gz 2>/dev/null | head -20
              if [ $PIP_COUNT -gt 20 ]; then
                  echo "... and $(($PIP_COUNT - 20)) more files"
              fi

              echo ""
              echo "=== pip package extraction completed successfully ==="
          else
              echo "No pip packages specified, skipping pip download"
          fi

          echo ""
          echo "=== All package extraction completed successfully ==="
          exit 0
          SCRIPT_EOF
          chmod +x download_packages.sh

      - name: Build extraction container
        env:
          BASE_IMAGE: ${{ inputs.base_image }}
          INCLUDE_RECOMMENDS: ${{ inputs.include_recommends }}
          APT_PACKAGES: ${{ inputs.dockerfile_path != '' && env.EXTRACTED_PACKAGES || inputs.apt_packages }}
          PIP_PACKAGES: ${{ inputs.pip_packages }}
        run: |
          docker build \
              --build-arg BASE_IMAGE="$BASE_IMAGE" \
              --build-arg INCLUDE_RECOMMENDS="$INCLUDE_RECOMMENDS" \
              --build-arg APT_PACKAGES="$APT_PACKAGES" \
              --build-arg PIP_PACKAGES="$PIP_PACKAGES" \
              -f Dockerfile.extract \
              -t apt-extractor .

      - name: Extract packages from container
        run: |
          echo "Running container to download packages..."
          docker run --name apt-extractor-container apt-extractor
          CONTAINER_EXIT_CODE=$?

          echo ""
          echo "Container exit code: $CONTAINER_EXIT_CODE"

          if [ $CONTAINER_EXIT_CODE -ne 0 ]; then
              echo ""
              echo "WARNING: Container exited with code $CONTAINER_EXIT_CODE"
              echo "Checking container logs for errors..."
              echo ""
              docker logs apt-extractor-container || true
              echo ""
              echo "Attempting to copy files anyway..."
          fi

          echo ""
          echo "Copying packages from container..."

          # Ensure target directories exist
          mkdir -p apt-packages
          mkdir -p pip-packages
          mkdir -p scripts

          echo "Copying /packages from container..."
          docker cp apt-extractor-container:/packages/. ./apt-packages/ || {
              echo "ERROR: Failed to copy /packages from container"
              echo "Container status:"
              docker ps -a --filter "name=apt-extractor-container"
              exit 1
          }

          echo "Copying /pip-packages from container..."
          docker cp apt-extractor-container:/pip-packages/. ./pip-packages/ 2>/dev/null || echo "No pip packages found"

          echo "Copying /scripts/package_manifest.txt from container..."
          docker cp apt-extractor-container:/scripts/package_manifest.txt ./scripts/ 2>/dev/null || echo "Warning: No manifest file found"

          echo ""
          echo "Removing container..."
          docker rm apt-extractor-container

          # Copy manifest to root
          if [ -f scripts/package_manifest.txt ]; then
              cp scripts/package_manifest.txt ${{ env.MANIFEST_FILE }}
          fi

          echo ""
          echo "Downloaded APT packages:"
          ls -lh apt-packages/*.deb 2>/dev/null | head -20 || echo "No .deb files found in apt-packages/"

          TOTAL_DEBS=$(ls -1 apt-packages/*.deb 2>/dev/null | wc -l)
          if [ "$TOTAL_DEBS" -gt 20 ]; then
              echo "... and $(($TOTAL_DEBS - 20)) more files"
          fi

          echo ""
          echo "Total APT package count: $TOTAL_DEBS"

          echo ""
          echo "Downloaded pip packages:"
          ls -lh pip-packages/*.whl pip-packages/*.tar.gz 2>/dev/null | head -20 || echo "No pip files found in pip-packages/"

          TOTAL_PIP=$(ls -1 pip-packages/*.whl pip-packages/*.tar.gz 2>/dev/null | wc -l)
          if [ "$TOTAL_PIP" -gt 20 ]; then
              echo "... and $(($TOTAL_PIP - 20)) more files"
          fi

          echo ""
          echo "Total pip package count: $TOTAL_PIP"

          # Check if at least one type of package was downloaded
          if [ "$TOTAL_DEBS" -eq 0 ] && [ "$TOTAL_PIP" -eq 0 ]; then
              echo ""
              echo "ERROR: No packages were downloaded!"
              echo ""
              echo "Checking container files..."
              docker run --rm apt-extractor ls -la /packages 2>/dev/null || echo "Could not list container APT files"
              docker run --rm apt-extractor ls -la /pip-packages 2>/dev/null || echo "Could not list container pip files"
              echo ""
              echo "Package manifest contents:"
              cat scripts/package_manifest.txt 2>/dev/null || echo "No manifest file found"
              exit 1
          fi

      - name: Create installation script
        run: |
          cat > scripts/install_packages.sh << 'INSTALL_EOF'
          #!/bin/bash
          set -e

          echo "========================================"
          echo "APT Package Installation Script"
          echo "========================================"
          echo

          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          TAR_FILE="${1:-apt-packages-*.tar.gz}"

          if [ ! -f $TAR_FILE ]; then
              echo "Error: Cannot find package archive: $TAR_FILE"
              echo "Usage: $0 [archive_file.tar.gz]"
              exit 1
          fi

          echo "Archive: $TAR_FILE"
          echo "Extracting..."
          tar -xzf "$TAR_FILE"

          echo ""
          echo "Installing packages (requires sudo)..."
          echo "This may take a while..."

          if [ "$EUID" -ne 0 ]; then
              echo "Restarting with sudo..."
              exec sudo bash "$0" "$@"
          fi

          # Install all .deb files
          dpkg -i *.deb || true

          # Fix any broken dependencies
          echo ""
          echo "Fixing broken dependencies..."
          apt-get install -f -y

          echo ""
          echo "Cleaning up..."
          rm -f *.deb
          rm -f "$0"

          echo ""
          echo "========================================"
          echo "Installation completed successfully!"
          echo "========================================"
          INSTALL_EOF

          chmod +x scripts/install_packages.sh

          # Create standalone version for archive
          cat > scripts/install_packages_standalone.sh << 'STANDALONE_EOF'
          #!/bin/bash
          set -e

          # This script must be in the same directory as the .deb and pip files
          # Extract the tar.gz first, then run this script

          echo "========================================"
          echo "Offline Package Installation Script"
          echo "========================================"

          if [ "$EUID" -ne 0 ]; then
              echo "This script requires root privileges. Restarting with sudo..."
              exec sudo bash "$0" "$@"
          fi

          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          DEB_COUNT=$(ls -1 *.deb 2>/dev/null | wc -l)
          PIP_COUNT=$(ls -1 *.whl *.tar.gz 2>/dev/null | wc -l)

          echo ""
          echo "Found packages:"
          echo "  - APT packages: $DEB_COUNT"
          echo "  - pip packages: $PIP_COUNT"
          echo ""

          # Install APT packages
          if [ "$DEB_COUNT" -gt 0 ]; then
              echo "=== Installing APT packages ==="
              dpkg -i *.deb || true
              echo ""
              echo "Fixing broken dependencies..."
              apt-get install -f -y
              echo "✓ APT packages installed"
              echo ""
          fi

          # Install pip packages
          if [ "$PIP_COUNT" -gt 0 ]; then
              echo "=== Installing pip packages ==="

              # Check if pip3 is available
              if ! command -v pip3 &> /dev/null; then
                  echo "Error: pip3 is not installed. Please install python3-pip first."
                  echo "You can install it with: apt-get install -y python3-pip"
                  exit 1
              fi

              echo "Installing pip packages..."
              pip3 install --no-index --find-links=. *.whl *.tar.gz 2>/dev/null || \
              pip3 install --no-index --find-links=. *.whl 2>/dev/null || \
              pip3 install --no-index --find-links=. *.tar.gz

              echo "✓ pip packages installed"
              echo ""
          fi

          # Clean up
          echo "=== Cleaning up ==="
          rm -f *.deb *.whl *.tar.gz

          echo ""
          echo "========================================"
          echo "Installation completed successfully!"
          echo "========================================"
          STANDALONE_EOF

          chmod +x scripts/install_packages_standalone.sh

      - name: Create tar archive with installation script
        run: |
          # Copy installation script to packages directory
          cp scripts/install_packages_standalone.sh apt-packages/install_packages.sh

          # Copy pip packages to the same directory
          if [ -d pip-packages ] && [ "$(ls -A pip-packages)" ]; then
              cp pip-packages/*.whl pip-packages/*.tar.gz apt-packages/ 2>/dev/null || true
          fi

          cd apt-packages
          DEB_COUNT=$(ls -1 *.deb 2>/dev/null | wc -l)
          PIP_COUNT=$(ls -1 *.whl *.tar.gz 2>/dev/null | wc -l)
          tar -czf ../${{ env.PACKAGE_FILE }} *.deb *.whl *.tar.gz install_packages.sh
          cd ..

          echo ""
          echo "Archive created: ${{ env.PACKAGE_FILE }}"
          echo "Size: $(du -h ${{ env.PACKAGE_FILE }} | cut -f1)"
          echo "Contains: $DEB_COUNT APT packages + $PIP_COUNT pip packages + installation script"

      - name: Display package information
        run: |
          TOTAL_DEBS=$(ls -1 apt-packages/*.deb 2>/dev/null | wc -l)
          TOTAL_PIP=$(ls -1 pip-packages/*.whl pip-packages/*.tar.gz 2>/dev/null | wc -l)

          echo ""
          echo "========================================"
          echo "Package Archive Information"
          echo "========================================"
          echo "File: ${{ env.PACKAGE_FILE }}"
          echo "Size: $(du -h ${{ env.PACKAGE_FILE }} | cut -f1)"
          echo "APT Packages: $TOTAL_DEBS"
          echo "pip Packages: $TOTAL_PIP"
          echo "Total: $((TOTAL_DEBS + TOTAL_PIP)) packages"
          echo "Manifest: ${{ env.MANIFEST_FILE }}"
          echo ""
          cat ${{ env.MANIFEST_FILE }}
          echo "========================================"

      - name: Upload to FTP server
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
        run: |
          # Determine remote path
          if [ "${{ inputs.ftp_create_subdir }}" = "true" ]; then
              REMOTE_PATH="${{ inputs.ftp_remote_path }}/${{ env.TIMESTAMP }}"
          else
              REMOTE_PATH="${{ inputs.ftp_remote_path }}"
          fi

          # Ensure path ends with /
          if [[ "${REMOTE_PATH: -1}" != "/" ]]; then
              REMOTE_PATH="${REMOTE_PATH}/"
          fi

          echo "=========================================="
          echo "开始上传到 FTP 服务器"
          echo "=========================================="
          echo "FTP 服务器: ${FTP_SERVER}:${{ inputs.ftp_port }}"
          echo "FTP 用户: ${FTP_USERNAME}"
          echo "远程路径: ${REMOTE_PATH}"
          echo ""

          # Build FTP URL
          FTP_BASE_URL="ftp://${FTP_SERVER}:${{ inputs.ftp_port }}${REMOTE_PATH}"

          # Upload with retry logic
          ATTEMPT=1
          MAX_ATTEMPTS=${{ inputs.max_retries }}

          upload_file() {
              local local_file="$1"
              local remote_file="$2"

              echo "上传: $local_file -> $remote_file"

              if curl -T "$local_file" \
                  "${FTP_BASE_URL}${remote_file}" \
                  --user "${FTP_USERNAME}:${FTP_PASSWORD}" \
                  --ftp-create-dirs \
                  --connect-timeout 30 \
                  --max-time 600 \
                  -v; then
                  echo "✓ 上传成功: $remote_file"
                  return 0
              else
                  echo "✗ 上传失败: $remote_file"
                  return 1
              fi
          }

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
              echo "=========================================="
              echo "上传尝试 $ATTEMPT / $MAX_ATTEMPTS"
              echo "=========================================="

              # Upload all files
              if upload_file "${{ env.PACKAGE_FILE }}" "${{ env.PACKAGE_FILE }}" && \
                 upload_file "${{ env.MANIFEST_FILE }}" "${{ env.MANIFEST_FILE }}" && \
                 upload_file "scripts/install_packages.sh" "${{ inputs.install_script_path }}"; then
                  echo ""
                  echo "=========================================="
                  echo "✅ 所有文件上传成功!"
                  echo "=========================================="
                  break
              else
                  echo ""
                  echo "上传失败 (尝试 $ATTEMPT)"
                  if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                      echo "等待 10 秒后重试..."
                      sleep 10
                  fi
              fi
              ATTEMPT=$((ATTEMPT + 1))
          done

          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
              echo ""
              echo "=========================================="
              echo "❌ 错误: 上传失败，已重试 $MAX_ATTEMPTS 次"
              echo "=========================================="
              exit 1
          fi

      - name: Upload artifact to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: apt-packages-archive-${{ env.TIMESTAMP }}
          path: |
            ${{ env.PACKAGE_FILE }}
            ${{ env.MANIFEST_FILE }}
            scripts/install_packages.sh
          retention-days: 90
          compression-level: 9

      - name: Generate summary
        run: |
          TOTAL_DEBS=$(ls -1 apt-packages/*.deb 2>/dev/null | wc -l)
          TOTAL_PIP=$(ls -1 pip-packages/*.whl pip-packages/*.tar.gz 2>/dev/null | wc -l)

          echo "========================================" >> $GITHUB_STEP_SUMMARY
          echo "✅ 包提取完成!" >> $GITHUB_STEP_SUMMARY
          echo "========================================" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **压缩包**: ${{ env.PACKAGE_FILE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **文件大小**: $(du -h ${{ env.PACKAGE_FILE }} | cut -f1)" >> $GITHUB_STEP_SUMMARY
          echo "- **APT 包数量**: $TOTAL_DEBS" >> $GITHUB_STEP_SUMMARY
          echo "- **pip 包数量**: $TOTAL_PIP" >> $GITHUB_STEP_SUMMARY
          echo "- **总包数量**: $((TOTAL_DEBS + TOTAL_PIP))" >> $GITHUB_STEP_SUMMARY
          echo "- **清单文件**: ${{ env.MANIFEST_FILE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **FTP 位置**: ftp://${{ secrets.FTP_SERVER }}${{ inputs.ftp_remote_path }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 服务器安装方法" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# 从 FTP 下载并解压" >> $GITHUB_STEP_SUMMARY
          echo "wget ftp://${{ secrets.FTP_SERVER }}${{ inputs.ftp_remote_path }}${{ env.PACKAGE_FILE }}" >> $GITHUB_STEP_SUMMARY
          echo "tar -xzf ${{ env.PACKAGE_FILE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# 安装（压缩包中包含安装脚本）" >> $GITHUB_STEP_SUMMARY
          echo "./install_packages.sh" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "========================================" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          docker rmi apt-extractor || true
          rm -rf apt-packages pip-packages scripts Dockerfile.extract download_packages.sh
